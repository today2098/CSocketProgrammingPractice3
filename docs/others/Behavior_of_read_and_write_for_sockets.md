# ソケットに対する `read`, `write` の挙動

システムコール `read()`, `write()` は，ファイルに対して読み書きできるように，ソケットに対して読み書きすることでコネクションが確立している相手プロセスと通信（データのやり取り）することができる．

しかし，ソケットに対する `read()`, `write()` の挙動はファイルに対するものとは異なる．
このことはプレゼンテーション層の機能を実装するうえで重要であり，注意する必要がある．


## 0. `read`, `write` とは

<details>

### 0.1. ファイル記述子 (file descriptor)

ファイル記述子とは，非負整数値で表現されるもので，カーネル内に生成される「file 構造体[^0.1.1]」と呼ばれるものを一意に識別するインデックスである．

[^0.1.1]: 文献 [1] 内で使われた名称．「ファイルテーブル項目 (file table entry)」や「オープンファイル記述 (open file description)」とも呼ばれる．

file 構造体は，主に以下の情報が格納されており，プロセスとファイルの実態をつなぐ役割をもつ[^0.1.2]．

[^0.1.2]: 文献 [1] p.133-137 より.

- ファイル状態フラグ（読み専用か書き専用かなど，`open()` 指定したフラグ）
- ファイルの読み書き位置

プロセスは自身のファイル記述子テーブルを持っており，このファイル記述子から対応する file 構造体を参照することができる．


### 0.2. システムコール `read`, `write`

`read()`, `write()` は UNIX OS のシステムコールであり，低水準入出力（カーネルが提供する入出力機能）をサポートする．
`fgets()`, `fprintf()` などの標準入出力ライブラリ[^0.2]は，これらを用いて実装されている．

[^0.2]: 標準入出力ライブラリは，入出力するデータを一時的にバッファに保存し，1回のデータ入出力を比較的大きい単位で行うことで，実際の操作回数を減らしている．このような効率化を「バッファリング (buffering)」という．

引数にファイル記述子を指定することにより，任意のファイルを操作する．

```c
int fd = open("hoge.txt", O_RDONLY);  // ファイル記述子fdは"hoge.txt"に対応．
char buf[1024];
read(fd, buf, 5);  // "hoge.txt"から5バイト分のデータを取得．
```


### 0.3. ファイル記述子の汎用化

UNIX OS では，以下のようなものもファイルとみなしており，共通の操作方法 (`read`, `write`) で扱える（ファイル抽象化）．

- 入出力機器（標準入力，標準出力，標準エラー出力）
- ソケット
- 名前付きパイプ (FIFO)

ファイル記述子はこれらを参照するために汎用的に使うことができる．

```c
// 標準出力stdoutに文字列"Hello"を出力．printf("Hello")とほぼ同義．
write(fileno(stdout), "Hello", 5);
```

```c
int sock = socket(PF_INET, SOCK_STREAM, 0);  // ストリームソケットを作成し，ソケット記述子sockを返す．
...
// コネクションを確立．
...
const char *str = "Hello";
write(sock, str, strlen(str));  // コネクションが確立している相手プロセスに，文字列"Hello"を送信．
```

</details>


## 1. `read`, `write` の挙動

## 2. プレゼンテーション層に対応する部分の実装方針

## まとめ

## 参考文献

1. 富永和人・権藤克彦. 例解 UNIX/Linux プログラミング教室. オーム社, 2018, 507p.
1. M.J. Donahoo & K.L. Calvert. TCP/IP ソケットプログラミング C言語編. 小高知宏監訳, オーム社, 2003, 181p.
1. "ファイル記述子". Wikipedia. <https://ja.wikipedia.org/wiki/ファイル記述子>, (参照 2023-10-29).
